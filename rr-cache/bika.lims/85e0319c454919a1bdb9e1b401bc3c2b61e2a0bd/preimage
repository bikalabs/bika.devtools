from bika.lims import bikaMessageFactory as _
from bika.lims.browser import BrowserView
from bika.lims.config import POINTS_OF_CAPTURE
from bika.lims.interfaces import IFieldIcons
from bika.lims.utils import encode_header, createPdf, attachPdf
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.Utils import formataddr
from os.path import join
from pkg_resources import resource_filename
from Products.CMFCore.utils import getToolByName
from Products.CMFCore.WorkflowCore import WorkflowException
from Products.CMFPlone.utils import safe_unicode
from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
from smtplib import SMTPRecipientsRefused
from smtplib import SMTPServerDisconnected
from zope.component import getAdapters

import App
import Globals


class doPublish(BrowserView):

    """Pre/Re/Publish analysis requests"""
    template = ViewPageTemplateFile("mailtemplates/analysisrequest_results.pt")

    def __init__(self, context, request, action, analysis_requests):
        self.context = context
        self.request = request
        self.field_icons = {}

        # the workflow transition that invoked us
        self.action = action

        # the list of ARs that we will process.
        # Filter them here so we only publish those with verified analyses.
        workflow = getToolByName(self.context, 'portal_workflow')
        self.analysis_requests = []
        self.publish_states = ['verified', 'published']
        for ar in analysis_requests:
            if workflow.getInfoFor(ar, 'review_state') in self.publish_states \
                    or ar.getAnalyses(review_state=self.publish_states):
                self.analysis_requests.append(ar)

    def ResultOutOfRange(self, analysis):
        """ Template wants to know, is this analysis out of range?
        We scan IFieldIcons adapters, and return True if any IAnalysis
        adapters trigger a result.
        """
        adapters = getAdapters((analysis, ), IFieldIcons)
        for name, adapter in adapters:
            alerts = adapter()
            if alerts and analysis.UID() in alerts:
                return True

    def __call__(self):

        debug_mode = App.config.getConfiguration().debug_mode
        out_path = join(Globals.INSTANCE_HOME, 'var') if debug_mode else None
        workflow = getToolByName(self.context, 'portal_workflow')

        # reporting user
        member = self.context.portal_membership.getAuthenticatedMember()
        username = member.getUserName()
        self.reporter = self.user_fullname(username)
        self.reporter_email = self.user_email(username)
        self.reporter_signature = ""
        c = [x for x in self.bika_setup_catalog(portal_type='LabContact')
             if x.getObject().getUsername() == username]
        if c:
            sf = c[0].getObject().getSignature()
            if sf:
                self.reporter_signature = sf.absolute_url() + "/Signature"

        # lab address
        self.laboratory = laboratory = self.context.bika_setup.laboratory
        lab_address = laboratory.getPostalAddress() \
            or laboratory.getBillingAddress() \
            or laboratory.getPhysicalAddress()
        if lab_address:
            _keys = ['address', 'city', 'state', 'zip', 'country']
            _list = [lab_address.get(v) for v in _keys if lab_address.get(v)]
            self.lab_address = "<br/>".join(_list).replace("\n", "<br/>")
        else:
            self.lab_address = None

        for ar in self.analysis_requests:
            self.ar = ar
            self.contact = ar.getContact()
            self.pub_pref = self.contact.getPublicationPreference()

            # client address
            self.client = ar.aq_parent
            client_address = self.client.getPostalAddress() \
                or self.contact.getBillingAddress() \
                or self.contact.getPhysicalAddress()
            if client_address:
                _keys = ['address', 'city', 'state', 'zip', 'country']
                _list = [client_address.get(v) for v in _keys
                         if client_address.get(v)]
                addr = "<br/>".join(_list).replace("\n", "<br/>")
                self.client_address = addr
            else:
                self.client_address = None

            self.Footer = self.context.bika_setup.getResultFooter()

            self.any_drymatter = ar.getReportDryMatter()
            self.any_accredited = False

            out_fn = ar.Title()

            analyses = ar.getAnalyses(full_objects=True,
                                      review_state=self.publish_states)
            analyses.sort(
                lambda x, y: cmp(x.Title().lower(), y.Title().lower()))

            self.services = {}
            self.qcservices = {}

            for analysis in analyses:

                service = analysis.getService()
                poc = POINTS_OF_CAPTURE.getValue(service.getPointOfCapture())
                cat = service.getCategoryTitle()
                if poc not in self.services:
                    self.services[poc] = {}
                if cat not in self.services[poc]:
                    self.services[poc][cat] = []
                if service not in self.services[poc][cat]:
                    self.services[poc][cat].append(service)
                if (service.getAccredited()):
                    self.any_accredited = True

            for qcanalysis in ar.getQCAnalyses():
                service = qcanalysis.getService()
                qctype = ''
                if qcanalysis.portal_type == 'DuplicateAnalysis':
                    qctype = "d"
                elif qcanalysis.portal_type == 'ReferenceAnalysis':
                    qctype = qcanalysis.getReferenceType()
                else:
                    continue

                if qctype not in self.qcservices:
                    self.qcservices[qctype] = {}
                poc = POINTS_OF_CAPTURE.getValue(service.getPointOfCapture())
                if poc not in self.qcservices[qctype]:
                    self.qcservices[qctype][poc] = {}
                cat = service.getCategoryTitle()
                if cat not in self.qcservices[qctype][poc]:
                    self.qcservices[qctype][poc][cat] = []
                # if service not in self.qcservices[qctype][poc][cat]:
                self.qcservices[qctype][poc][cat].append(
                    {'service': service,
                     'analysis': qcanalysis})

            # Create the html report
            ar_results = safe_unicode(self.template()).encode('utf-8')
            if out_path:
                open(join(out_path, out_fn + ".html"), "w").write(ar_results)

            # Create the pdf report (will always be attached to the AR)
            pdf_outfile = join(out_path, out_fn + ".pdf") if out_path else None
            pdf_css = resource_filename(
                "bika.lims", "skins/bika/analysisrequest_results_pdf.css")
            ar_css = join(self.portal_url, "analysisrequest_results.css")
            ar_results = ar_results.replace(ar_css, pdf_css)
            pdf_report = createPdf(ar_results, pdf_outfile, css=pdf_css)

            if pdf_report:
                reportid = self.context.generateUniqueId('ARReport')
                ar.invokeFactory(id=reportid, type_name="ARReport")
                report = ar._getOb(reportid)
                report.edit(
                    AnalysisRequest=ar.UID(),
                    Pdf=pdf_report,
                    Html=ar_results,
                    Recipients=[{'UID': self.contact.UID(),
                                'Username': self.contact.getUsername(),
                                'Fullname': self.contact.getFullname(),
                                'EmailAddress': self.contact.getEmailAddress(),
                                'PublicationModes': self.pub_pref
                                 }]
                )
                report.unmarkCreationFlag()
                from bika.lims.idserver import renameAfterCreation
                renameAfterCreation(report)

                # Set status to published
                if self.action == 'publish':
                    try:
                        workflow.doActionFor(ar, 'publish')
                    except WorkflowException:
                        pass

                # compose and send email
                if 'email' in self.pub_pref:
                    mime_msg = MIMEMultipart('related')
                    mime_msg['Subject'] = self.get_mail_subject(ar)[0]
                    mime_msg['From'] = formataddr(
                        (encode_header(laboratory.getName()),
                         laboratory.getEmailAddress()))

                    to = []
                    contact = ar.getContact()
                    if contact:
                        to.append(formataddr((encode_header(contact.Title()),
                                              contact.getEmailAddress())))
                    for cc in ar.getCCContact():
                        formatted = formataddr((encode_header(cc.Title()),
                                               cc.getEmailAddress()))
                        if formatted not in to:
                            to.append(formatted)
                    mime_msg['To'] = ','.join(to)
                    mime_msg.preamble = 'This is a multi-part MIME message.'
                    msg_txt = MIMEText(ar_results, _subtype='html')
                    mime_msg.attach(msg_txt)

                    # Attach the pdf to the email if requested
                    if pdf_report and 'pdf' in self.pub_pref:
                        attachPdf(mime_msg, pdf_report, out_fn)

                    # For now, I will simply ignore mail send under test.
                    if hasattr(self.portal, 'robotframework'):
                        continue

                    try:
                        host = getToolByName(self.context, 'MailHost')
                        host.send(mime_msg.as_string(), immediate=True)
                    except SMTPServerDisconnected as msg:
                        if not debug_mode:
                            raise SMTPServerDisconnected(msg)
                    except SMTPRecipientsRefused as msg:
                        raise WorkflowException(str(msg))

                else:
                    raise Exception("XXX pub_pref %s" % self.pub_pref)

        return [ar.RequestID for ar in self.analysis_requests]

<<<<<<<
    def formattedResult(self, analysis):
        """Formatted result:
        1. Print ResultText of matching ResulOptions
        2. If the result is floatable, render it to the correct precision
        If analysis is None, returns empty string
        """
        if analysis is None:
            return ''

        result = analysis.getResult()
        service = analysis.getService()
        choices = service.getResultOptions()

        # 1. Print ResultText of mathching ResulOptions
        match = [x['ResultText'] for x in choices
                 if str(x['ResultValue']) == str(result)]
        if match:
            return match[0]

        # 2. If the result is floatable, render it to the correct precision
        precision = service.getPrecision()
        if not precision:
            precision = ''
        try:
            result = str("%%.%sf" % precision) % float(result)
=======
    def getResult(self, analysis):
        result = analysis.getResult()
        service = analysis.getService()
        choices = service.getResultOptions()
        for choice in choices:
            if choice['ResultValue'] == result:
                return choice['ResultText']

        precision = service.getPrecision()
        try:
            result = str('%%.%sf' % precision) % float(result)
>>>>>>>
        except:
            pass

        return result

<<<<<<<
    def containsInvalidARs(self):
=======
    def get_managers_from_requests(self):
        ## Script (Python) "get_managers_from_requests"
        ##bind container=container
        ##bind context=context
        ##bind namespace=
        ##bind script=script
        ##bind subpath=traverse_subpath
        ##parameters=batch
        ##title=Get services from requests
        ##
        managers = {'ids': [],
                    'dict': {}}
        departments = {}
>>>>>>>
        for ar in self.batch:
            if ar.isInvalid():
                return True
        return False

    def get_managers_from_request(self, ar):
        managers = {'ids': [], 'dict': {}}
        departments = {}
        ar_mngrs = ar.getResponsible()
        for id in ar_mngrs['ids']:
            new_depts = ar_mngrs['dict'][id]['departments'].split(',')
            if id in managers['ids']:
                for dept in new_depts:
                    if dept not in departments[id]:
                        departments[id].append(dept)
            else:
                departments[id] = new_depts
                managers['ids'].append(id)
                managers['dict'][id] = ar_mngrs['dict'][id]

        mngrs = departments.keys()
        for mngr in mngrs:
            final_depts = ''
            for dept in departments[mngr]:
                if final_depts:
                    final_depts += ', '
                final_depts += dept
            managers['dict'][mngr]['departments'] = final_depts

        return managers

    def get_mail_subject(self, ar):
        client = ar.aq_parent
        subject_items = client.getEmailSubject()
        ai = co = cr = cs = False
        if 'ar' in subject_items:
            ai = True
        if 'co' in subject_items:
            co = True
        if 'cr' in subject_items:
            cr = True
        if 'cs' in subject_items:
            cs = True
        ais = []
        cos = []
        crs = []
        css = []
        blanks_found = False
        if ai:
            ais.append(ar.getRequestID())
        if co:
            if ar.getClientOrderNumber():
                if not ar.getClientOrderNumber() in cos:
                    cos.append(ar.getClientOrderNumber())
            else:
                blanks_found = True
        if cr or cs:
            sample = ar.getSample()
        if cr:
            if sample.getClientReference():
                if not sample.getClientReference() in crs:
                    crs.append(sample.getClientReference())
            else:
                blanks_found = True
        if cs:
            if sample.getClientSampleID():
                if not sample.getClientSampleID() in css:
                    css.append(sample.getClientSampleID())
            else:
                blanks_found = True
        tot_line = ''
        if ais:
            ais.sort()
            ar_line = _('ARs: %s') % ', '.join(ais)
            tot_line = ar_line
        if cos:
            cos.sort()
            cos_line = _('Orders: %s') % ', '.join(cos)
            if tot_line:
                tot_line += ' '
            tot_line += cos_line
        if crs:
            crs.sort()
            crs_line = _('Refs: %s') % ', '.join(crs)
            if tot_line:
                tot_line += ' '
            tot_line += crs_line
        if css:
            css.sort()
            css_line = _('Samples: %s') % ', '.join(css)
            if tot_line:
                tot_line += ' '
            tot_line += css_line
        if tot_line:
            subject = _('Analysis results for %s') % tot_line
            if blanks_found:
                subject += (' ' + _('and others'))
        else:
            subject = _('Analysis results')
        return subject, tot_line

    def get_titles_for_uids(self, *uids):
        uc = getToolByName(self.context, 'uid_catalog')
        return [p.getObject().Title() for p in uc(UID=uids)]
